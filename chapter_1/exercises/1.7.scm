; ex 1.7

; возводит x в квадрат
(define (square x)
	(* x x)	
)

; определяет расстояние между x и y
(define (distance x y)
	(abs (- x y))
)

; вычисляет среднее значение между x и y
(define (average x y)
	(/ (+ x y) 2)		
)

; вычисляет новое приближение квадратного корня от x
(define (improve guess x)
	(average guess (/ x guess))
)

; вычисляет корень числа x (оригинальное решение)
(define (sqrt x)

  	; определяет, с достаточной ли точностью мы определили корень
	; (для этого измеряется, насколько близок квадрат приближения к x)
	(define (good-enough? guess x)
		(< (distance x (square guess)) 0.001)
	)

	(define (sqrt-iter guess x)
		(if (good-enough? guess x)
			guess
			(sqrt-iter (improve guess x) x)
		)
	)

	(sqrt-iter 1.0 x)

)

; вычисляет корень числа x (оптимизированное решение)
(define (sqrt-optimized x)
	
 	; определяет, с достаточной ли точностью мы определили корень
 	(define (good-enough? guess prev-guess)
 		(= guess prev-guess)
 	)

 	(define (sqrt-iter guess prev-guess x)
 		(if (good-enough? guess prev-guess)
 			guess
 			(sqrt-iter (improve guess x) guess x)
 		)
 	)

 	(sqrt-iter 1.0 0 x)

 )

; ОТВЕТ:
; Оптимизированная процедура работает значительно лучше на больших и маленьких числах. Оригинальный
; вариант впадал в бесконечную рекурсию на очень больших числах и возвращал неточные результаты
; на очень малых.
;
; КОММЕНТАРИИ:
; 
; В первой версией моего решения я определял, что мы нашли решение следующим образом:
; 	(define (good-enough? guess prev-guess)
; 		(< (distance guess prev-guess) 0.001)
; 	)
;
; На больших числах это решение работало хорошо, однако на очень малых я получал все менее точные
; результаты. Однако в целом я был удовлетворен и поэтому отправился смотреть решения на 
; http://community.schemewiki.org/?sicp-ex-1.7.
;
; Там было предложено немного другое решения (расчет расстояния я заменил функцией distance):
;
; 	(define (good-enough? guess prev-guess)
; 		(< (distance guess prev-guess) (* guess 0.001))
; 	)
;
; Данное решение сперва показалось мне более верным, и кроме того оно ощутимо увеличило точность
; на очень малых числах. Однако вместе с тем появлялась неточность при работе с большими числами,
; которой раньше не было (поскольку предел толерантности был ниже).
;
; Одним из выходов было снижение толерантности до 0.0001 или даже ниже.
;
; Однако на странице http://community.schemewiki.org/?sicp-ex-1.7 было предложено другое решение,
; которое позволило добиться максимальной точности вообще без использования толерантности:
;
; 	(define (good-enough? guess prev-guess)
; 		(= guess prev-guess)
;	)
;
; Это решение показалось мне наилучшим. Оно использует тот факт, что процедура improve в конечном
; итоге возвращает то же самое приближение, которое было ей передано.

; testing:

; 1. SMALL NUMBERS:

; 1.1. sqrt(0.0025) = 0.05

(sqrt 0.0025)
; =>  0.05423762280896765

(sqrt-optimized 0.0025) 
; => 0.05

; 1.2. sqrt(0.000025) = 0.005

(sqrt 0.000025)
; => 0.031515954454847304

(sqrt-optimized 0.000025) 
; => 0.005

; 1.3. sqrt(0.000025) = 0.0005

(sqrt 0.00000025)
; => 0.03125266401721204

(sqrt-optimized 0.00000025) 
; => 0.0005

; 2. LARGE NUMBERS:

(define (pow x n)
	(if (= n 1)
		x
		(* x (pow x (- n 1)))    
	)  
)

; 2.1. sqrt(10 ^ 24) = 10 ^ 12 = 1e+12 = 1 000 000 000 000

(sqrt (pow 10 24))
; => 1000000000000

(sqrt-optimized (pow 10 24))
; => 1000000000000

; 2.2. sqrt(10 ^ 46) = 10 ^ 23 = 1e+23

(sqrt (pow 10 46))
; => Aborting!: maximum recursion depth exceeded

(sqrt-optimized (pow 10 46))
; => 1e+23
